<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arduino Pro Micro Bridge</title>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 20px; background: #f0f4f8; }
        .container { background: white; padding: 30px; border-radius: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); display: inline-block; min-width: 300px; }
        button { padding: 15px 30px; font-size: 18px; border: none; border-radius: 10px; cursor: pointer; transition: 0.2s; }
        #connect { background: #28a745; color: white; }
        #connect:hover { background: #218838; }
        #status { margin-top: 15px; color: #666; font-style: italic; }
        .value-box { font-size: 48px; font-weight: bold; color: #007bff; margin: 20px 0; }
    </style>
</head>
<body>

<div class="container">
    <h2>USB Bridge</h2>
    <div id="status">Status: Waiting for Connect</div>
    <div class="value-box" id="display">0</div>
    <button id="connect">CONNECT ARDUINO</button>
</div>

<script>
    let device;
const decoder = new TextDecoder();
const encoder = new TextEncoder();

document.getElementById('connect').addEventListener('click', async () => {
    const statusEl = document.getElementById('status');
    try {
        device = await navigator.usb.requestDevice({ filters: [] });
        await device.open();
        if (device.configuration === null) await device.selectConfiguration(1);

        // Try interfaces 2, then 0, then 1 (CDC standard)
        let success = false;
        for (let itf of [2, 0, 1]) {
            try {
                await device.claimInterface(itf);
                
                // Set DTR Signal so Pro Micro starts sending
                await device.controlTransferOut({
                    requestType: 'class', recipient: 'interface',
                    request: 0x22, value: 0x01, index: itf
                });

                // Check if this interface actually has "Bulk" endpoints (the data pipes)
                const endpoints = device.configuration.interfaces[itf].alternates[0].endpoints;
                const inEndpoint = endpoints.find(e => e.direction === 'in');
                const outEndpoint = endpoints.find(e => e.direction === 'out');

                if (inEndpoint && outEndpoint) {
                    statusEl.innerText = `Connected! Interface: ${itf}, EP: ${inEndpoint.endpointNumber}`;
                    statusEl.style.color = "green";
                    readLoop(itf, inEndpoint.endpointNumber, outEndpoint.endpointNumber);
                    success = true;
                    break;
                }
            } catch (e) { console.log(`Itf ${itf} failed.`); }
        }

        if (!success) statusEl.innerText = "Connected, but no data pipes found.";

    } catch (err) {
        statusEl.innerText = "Error: " + err.message;
    }
});

async function readLoop(itf, epIn, epOut) {
    const displayEl = document.getElementById('display');
    while (device && device.opened) {
        try {
            // Read from the identified IN endpoint
            const result = await device.transferIn(epIn, 64);
            
            if (result.data && result.data.byteLength > 0) {
                const text = decoder.decode(result.data).trim();
                if (text) {
                    displayEl.innerText = text;
                    // ECHO: Send back through identified OUT endpoint
                    await device.transferOut(epOut, encoder.encode(text + "\n"));
                }
            }
        } catch (e) {
            console.error("Loop Error:", e);
            break;
        }
    }
}
</script>
</body>
</html>
